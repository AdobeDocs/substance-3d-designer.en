<header><meta name="title" content="Using threads | Substance 3D Designer"><meta name="description" content=""><meta name="helpx_description" content="Designer > Scripting > Using threads"></header><body><div class="dexter-Position is-Editor-false" daa-im="true" daa-lh="Helpx In-article Navigation" data-animations="[]" id="root_content_flex_items_position" role="">
<div class="aem-Grid aem-Grid--12 aem-Grid--default--12">
<div class="text first-heading aem-GridColumn aem-GridColumn--default--12">
<div class="cmp-text">
<h1 id="mainpagetitle">Using threads</h1>
</div>
</div>
<div class="text aem-GridColumn aem-GridColumn--default--12">
<div class="cmp-text">
<p>It is possible for plugins to <b>create threads</b> using Python's threading module <i>or</i> Qt for Python threading related classes.</p>
<p>This can be useful to perform background processing or I/O operations while Designer is running.</p>
<p>It is important to note that most classes and methods in Designer's Python API can <i>only</i> be called from the <b>main application thread</b>. As such, if you want to make any modification to any graph that is currently opened in Designer, you must make them from the main application thread.</p>
<p>One possible solution is to use <b>QThread</b> and <b>Queued connections</b>,Â like in the following example:</p>
</div>
</div>
<div class="codeblock parbase aem-GridColumn aem-GridColumn--default--12"><div></div>
<pre data-enlighter-language="plain" data-gutter="true">import time 
from PySide2 import QtCore 
 
 
# Our thread object. 
class TimerThread(QtCore.QThread): 
    tick = QtCore.Signal() 
 
    def run(self): 
        for i in range(0, 7): 
            print("Emitting signal from thread %s" % QtCore.QThread.currentThread()) 
            self.tick.emit() 
            time.sleep(0.5) 
 
 
# Our receiver object, created on the main thread. 
class Receiver(QtCore.QObject): 
    def __init__(self, parent=None): 
        super(Receiver, self).__init__(parent) 
 
    def onTick(self): 
        # This is called on the main thread. It is safe to use the sd API here. 
        print("Tick received in thread %s" % QtCore.QThread.currentThread()) 
 
 
timer = TimerThread() 
receiver = Receiver() 
 
# Use QtCore.Qt.QueuedConnection to make sure that slots are called on the main thread. 
# You can also use QtCore.Qt.BlockingQueuedConnection if you need to block while the slot is called. 
timer.tick.connect(receiver.onTick, QtCore.Qt.QueuedConnection) 
 
# Start out thread. 
timer.start()</pre>
</div>
</div>
</div></body>